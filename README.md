# @esroyo/deno-bump-workspaces

> A tool for upgrading Deno workspace packages using conventional commits

[![JSR](https://jsr.io/badges/@esroyo/deno-bump-workspaces)](https://jsr.io/@esroyo/deno-bump-workspaces)
[![JSR Score](https://jsr.io/badges/@esroyo/deno-bump-workspaces/score)](https://jsr.io/@esroyo/deno-bump-workspaces)
[![ci](https://github.com/esroyo/bump-workspaces/actions/workflows/ci.yml/badge.svg)](https://github.com/esroyo/bump-workspaces/actions/workflows/ci.yml)
[![codecov](https://codecov.io/gh/esroyo/bump-workspaces/graph/badge.svg?token=9Y9L5BV24U)](https://codecov.io/gh/esroyo/bump-workspaces)

This tool detects necessary version upgrades for workspaces packages using
[Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) and
creates a PR with automatic tagging. Compatible with the original
[@deno/bump-workspaces](https://github.com/denoland/bump-workspaces).

# Try it

Run this command with `--dry-run` flag in your Deno project and see what this
command does:

```sh
deno run -A jsr:@esroyo/deno-bump-workspaces/cli --dry-run
```

This works with both:

- **Workspace repositories**: Projects with a `workspace` field in `deno.json`
- **Single-package repositories**: Projects with `name` and `version` fields in
  `deno.json`

# How it works

The library works with both workspace and single-package repositories:

**For workspace repositories:**

- Read `deno.json` and its "workspace" field. Read `deno.json` of each workspace
  package.

**For single-package repositories:**

- Read `deno.json` with "name" and "version" fields (no "workspace" field
  needed).

**Common workflow:**

- Collect the git commit messages between the latest tag and the current branch.
- Calculate the necessary updates for each package. (See the below table for
  what version upgrades are performed for each conventional commit tag.)
- Create and print the release note.
- Stop here if `--dry-run` specified, and continue if not.
- Save necessary updates to each `deno.json`.
- Create git tags automatically (if `--git-tag` specified).
- Create a new branch `release-YYYY-MM-DD`
- Make git commit the version changes using `GIT_USER_NAME` and `GIT_USER_EMAIL`
  env vars.
- Create a github pull request using `GITHUB_TOKEN` and `GITHUB_REPOSITORY` env
  vars.
- That's all.

Note: Don't worry if your commits don't completely follow conventional commits.
You can still manually update the PR generated by this tool. The PR body
includes the information about which commits are handled by this tool and which
are not.

## ⚠️ Important: GitHub Merge Strategy

When merging PRs created by this tool with automatic tagging enabled
(`--git-tag` flag), use **"Create a merge commit"** to preserve tag references.
Avoid "Squash and merge" or "Rebase and merge" as they rewrite commit history
and break the automatic tagging feature.

# CI set up

Set up the GitHub Actions yaml like the below, and trigger the workflow
manually:

```yaml
name: version_bump

# Configure your repo Settings > Actions > General > Workflow permissions
permissions:
  contents: write
  pull-requests: write

on: workflow_dispatch

jobs:
  build:
    name: version bump
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Clone repository
        uses: actions/checkout@v4

      - name: Set up Deno
        uses: denoland/setup-deno@v1

      - name: Run workspaces version bump
        run: |
          git fetch --unshallow origin
          deno run -A jsr:@esroyo/deno-bump-workspaces/cli
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

Example pull request: https://github.com/kt3k/deno_std/pull/34

## Commit titles

This tool uses the commit titles as the input for detecting which modules and
versions to update. The commit titles need to follow the following format:

```
<tag>(<scopes,...>): <commit message>
```

Some examples are:

```
fix(foo): fix a bug
fix(baz,qux): fix a bug
feat(bar): add a new feature
feat(bar)!: add a breaking feature
chore(foo): clean up
chore(bar): clean up
BREAKING(quux): some breaking change
```

This example results in the following version updates:

| module | version |
| ------ | ------- |
| foo    | patch   |
| bar    | major   |
| baz    | patch   |
| qux    | patch   |
| quux   | major   |

The tool automatically detects following commit tags:

- BREAKING
- feat
- fix
- perf
- docs
- deprecation
- refactor
- test
- style
- chore

You can also mark any commit as breaking by adding `!` after the scope:

- `feat(scope)!: breaking feature` → major version bump
- `fix(scope)!: breaking fix` → major version bump

If a module has `BREAKING` commits or commits with `!`, then `major` version
will be updated. If a module has `feat` commits, `minor` version will be
updated. Otherwise `patch` version will be updated.

| tag         | version |
| ----------- | ------- |
| BREAKING    | major   |
| feat        | minor   |
| fix         | patch   |
| perf        | patch   |
| docs        | patch   |
| deprecation | patch   |
| refactor    | patch   |
| test        | patch   |
| style       | patch   |
| chore       | patch   |

## Scope required tags

The following tags require scope specified because they don't make sense without
scopes. If these tags specified without scopes, they are raised as diagnostics
in README.

- BREAKING
- feat
- fix
- perf
- deprecation

## Wildcard scope

You can use `*` for the scope. That commit affects all the packages in the
workspace. For example:

```
refactor(*): clean up
```

The above commit causes `patch` upgrade to the all packages.

## Unstable updates

You can mark the change only affects the unstable part of the package by using
`scope/unstable` or `unstable/scope`.

```
feat(crypto/unstable): a new unstable feature
BREAKING(crypto/unstable): breaking change to unstable feature
```

If this notation is used, the effect of the commit becomes `patch` no matter
what commit type is used.

# CLI Usage

Run this command with `--dry-run` flag in your Deno project and see what this
command does:

```sh
deno run -A jsr:@esroyo/deno-bump-workspaces/cli --dry-run
```

This works with both:

- **Workspace repositories**: Projects with a `workspace` field in `deno.json`
- **Single-package repositories**: Projects with `name` and `version` fields in
  `deno.json`

## Basic Options

```sh
# Dry run to see what would happen
deno run -A jsr:@esroyo/deno-bump-workspaces/cli --dry-run

# Use custom import map
deno run -A jsr:@esroyo/deno-bump-workspaces/cli --import-map ./import_map.json

# Use custom release note filename
deno run -A jsr:@esroyo/deno-bump-workspaces/cli --release-note-path CHANGELOG.md
```

## Release Strategies

The tool supports different strategies that can be combined:

### Tag Strategies

**Consolidated Tags (Default):**

```sh
# Multi-package repos: creates a release-YYYY.MM.DD tag
# Single-package repos: creates a v1.2.3 tag
deno run -A jsr:@esroyo/deno-bump-workspaces/cli
```

**Individual Tags (`--individual-tags`):**

```sh
# Multi-package repos: creates @scope/package@1.2.3 tags
# Single-package repos: creates a v1.2.3 tag
deno run -A jsr:@esroyo/deno-bump-workspaces/cli --individual-tags
```

### Release Notes Strategies

**Consolidated Release Notes (Default):**

- Creates single release note file in workspace root (default: `Releases.md`)
- Contains all package changes together

**Individual Release Notes (`--individual-release-notes`):**

- Creates release note files in each package directory (default filename:
  `Releases.md`)
- Each file contains changes specific to that package
- Use `--release-note-path CHANGELOG.md` to use `CHANGELOG.md` instead

### Git Tag Creation Control

**Manual Tags (Default - Compatible with original):**

```sh
# No automatic tag creation - you create tags manually after merging PR
deno run -A jsr:@esroyo/deno-bump-workspaces/cli
```

**Automatic Tags (`--git-tag`):**

```sh
# Creates and pushes tags automatically
deno run -A jsr:@esroyo/deno-bump-workspaces/cli --git-tag
```

### Tag Format Standards

The tool uses hardcoded, industry-standard tag formats:

- **Single packages**: `v1.2.3` (semver format)
- **Multi-package with individual tags**: `@scope/package@1.2.3` (npm-style)
- **Multi-package with consolidated tags**: `release-2025.01.15` (date-based)

## Strategy Combinations

```sh
# Default: Workspace strategy (consolidated tags + consolidated release notes)
deno run -A jsr:@esroyo/deno-bump-workspaces/cli

# Per-package strategy (individual tags + individual release notes)
deno run -A jsr:@esroyo/deno-bump-workspaces/cli --individual-tags --individual-release-notes

# Per-package strategy with custom release note filename
deno run -A jsr:@esroyo/deno-bump-workspaces/cli --individual-tags --individual-release-notes --release-note-path CHANGELOG.md

# Mixed strategies
deno run -A jsr:@esroyo/deno-bump-workspaces/cli --individual-tags  # Individual tags, consolidated release notes
deno run -A jsr:@esroyo/deno-bump-workspaces/cli --individual-release-notes  # Consolidated tags, individual release notes

# With automatic tag creation
deno run -A jsr:@esroyo/deno-bump-workspaces/cli --individual-tags --individual-release-notes --git-tag
```

## Complete Examples

```sh
# Original behavior: PR only, manual tags (most compatible)
deno run -A jsr:@esroyo/deno-bump-workspaces/cli

# Modern workflow: automatic everything
deno run -A jsr:@esroyo/deno-bump-workspaces/cli --individual-tags --individual-release-notes --git-tag

# Review changes before creating tags
deno run -A jsr:@esroyo/deno-bump-workspaces/cli --individual-tags --individual-release-notes
# ... review the PR ...
# Add --git-tag when you're ready for automatic tagging

# Custom settings with CHANGELOG.md files
deno run -A jsr:@esroyo/deno-bump-workspaces/cli \
  --individual-tags \
  --individual-release-notes \
  --release-note-path CHANGELOG.md \
  --git-tag

# Local development workflow
deno run -A jsr:@esroyo/deno-bump-workspaces/cli \
  --dry-run \
  --individual-tags
```

All boolean options support `--no-*` flags to override defaults (e.g.,
`--no-individual-tags`, `--no-git-tag`).

## ⚠️ **Critical: GitHub Merge Strategy**

When merging PRs created by this library with automatic tagging enabled
(`--git-tag` flag), you **MUST** use the correct merge strategy:

### ✅ **Use: "Create a merge commit"**

- Preserves original commits and their hash IDs
- Tags created by the library remain valid
- Next run detects the correct starting point

### ❌ **Avoid: "Squash and merge" or "Rebase and merge"**

- Creates new commits with different hash IDs
- **Breaks tag references** - tags point to non-existent commits
- Next run will fail to find correct starting tag

### Recovery from Wrong Merge Strategy

If you accidentally used the wrong merge strategy:

```bash
# Find the actual commit on main branch
git log --oneline -3

# Delete the broken tag
git tag -d v1.2.3

# Recreate tag on the correct commit
git tag v1.2.3 <commitish>

# Force push the corrected tag
git push origin v1.2.3 --force
```

# License

MIT
